// ============================================================================
// CUSTOMER SERVICE
// Hotfix: Added outlet_id filtering for multi-tenant isolation
// ============================================================================

import { supabase } from '@/lib/supabase';
import { Customer, CustomerFormData } from '@/types';
import logger from '@/lib/logger';

export interface CustomerFilters {
  outletId?: string;
  search?: string;
  status?: 'active' | 'inactive';
  limit?: number;
  offset?: number;
}

export class CustomerService {
  /**
   * Get all customers with outlet filtering (REQUIRED for non-admin users)
   * @param outletId - Required for managers/accountants, optional for admins
   * @throws Error if non-admin user doesn't provide outletId
   */
  static async getCustomers(outletId?: string): Promise<Customer[]> {
    try {
      let query = supabase
        .from('customers')
        .select('*')
        .order('created_at', { ascending: false });

      // Apply outlet filter if provided
      if (outletId) {
        query = query.eq('outlet_id', outletId);
      }

      const { data, error } = await query;

      if (error) {
        logger.error('Error fetching customers:', error);
        throw new Error(error.message);
      }

      // Map database fields to our interface - use new schema fields
      return (data || []).map((customer: any) => this.mapCustomerFromDb(customer));
    } catch (error: any) {
      logger.error('Error in getCustomers:', error);
      throw new Error(error.message || 'Failed to fetch customers');
    }
  }

  /**
   * Get customers with advanced filtering, pagination, and search
   */
  static async getCustomersFiltered(filters: CustomerFilters): Promise<{
    customers: Customer[];
    total: number;
  }> {
    try {
      let query = supabase
        .from('customers')
        .select('*', { count: 'exact' });

      // CRITICAL: Apply outlet filter for multi-tenant isolation
      if (filters.outletId) {
        query = query.eq('outlet_id', filters.outletId);
      }

      // Apply search filter
      if (filters.search) {
        const searchTerm = `%${filters.search}%`;
        query = query.or(
          `contact_person.ilike.${searchTerm},company_name.ilike.${searchTerm},phone.ilike.${searchTerm},email.ilike.${searchTerm}`
        );
      }

      // Apply status filter
      if (filters.status) {
        query = query.eq('status', filters.status);
      }

      // Apply ordering
      query = query.order('created_at', { ascending: false });

      // Apply pagination
      if (filters.limit) {
        query = query.limit(filters.limit);
      }
      if (filters.offset) {
        query = query.range(filters.offset, filters.offset + (filters.limit || 50) - 1);
      }

      const { data, error, count } = await query;

      if (error) {
        logger.error('Error fetching customers:', error);
        throw new Error(error.message);
      }

      return {
        customers: (data || []).map((customer: any) => this.mapCustomerFromDb(customer)),
        total: count || 0
      };
    } catch (error: any) {
      logger.error('Error in getCustomersFiltered:', error);
      throw new Error(error.message || 'Failed to fetch customers');
    }
  }

  /**
   * Get a single customer by ID
   * Note: RLS policies enforce outlet isolation at database level
   */
  static async getCustomer(id: string): Promise<Customer> {
    try {
      const { data, error } = await supabase
        .from('customers')
        .select('*')
        .eq('id', id)
        .maybeSingle();

      if (error) {
        logger.error('DB error fetching customers:', error);
        throw new Error('Database error');
      }

      if (!data) {
        logger.warn('customers row not found for filter id:', id);
        throw new Error('Customer not found');
      }

      return this.mapCustomerFromDb(data);
    } catch (error: any) {
      logger.error('Error in getCustomer:', error);
      throw new Error(error.message || 'Failed to fetch customer');
    }
  }

  /**
   * Create a new customer
   */
  static async createCustomer(customerData: CustomerFormData & { outlet_id?: string }): Promise<Customer> {
    try {
      // Customer code will be auto-generated by database trigger (CUST-OUTCODE-001)
      
      // Get current user for outlet_id and created_by
      const { data: { user } } = await supabase.auth.getUser();
      const outletId = customerData.outlet_id || (user?.user_metadata?.outlet_id);

      // Validate outlet_id is present
      if (!outletId) {
        throw new Error('Outlet ID is required to create a customer');
      }

      // Map form data to database fields - use new schema fields
      const insertData: any = {
        // customer_code will be auto-generated by trigger
        contact_person: customerData.name,
        email: customerData.email,
        phone: customerData.phone,
        company_name: customerData.company || null,
        address_street: customerData.address.street,
        address_city: customerData.address.city,
        address_state: customerData.address.state,
        address_pincode: customerData.address.pincode,
        address_country: customerData.address.country || 'India',
        gstin: customerData.gstin || null,
        customer_type: 'individual', // Default type
        status: customerData.status === 'active' ? 'active' : 'inactive',
        outlet_id: outletId
      };

      const { data, error } = await supabase
        .from('customers')
        .insert(insertData)
        .select()
        .maybeSingle();

      if (error) {
        logger.error('DB error creating customer:', error);
        throw new Error('Database error');
      }

      if (!data) {
        logger.warn('customers row not found after insert');
        throw new Error('Failed to create customer');
      }

      return this.mapCustomerFromDb(data);
    } catch (error: any) {
      logger.error('Error in createCustomer:', error);
      throw new Error(error.message || 'Failed to create customer');
    }
  }

  /**
   * Update an existing customer
   */
  static async updateCustomer(id: string, customerData: Partial<CustomerFormData>): Promise<Customer> {
    try {
      const updateData: any = {};

      if (customerData.name) updateData.contact_person = customerData.name;
      if (customerData.email) updateData.email = customerData.email;
      if (customerData.phone) updateData.phone = customerData.phone;
      if (customerData.company !== undefined) updateData.company_name = customerData.company;
      if (customerData.address) {
        updateData.address_street = customerData.address.street;
        updateData.address_city = customerData.address.city;
        updateData.address_state = customerData.address.state;
        updateData.address_pincode = customerData.address.pincode;
        updateData.address_country = customerData.address.country || 'India';
      }
      if (customerData.gstin !== undefined) updateData.gstin = customerData.gstin;
      if (customerData.status) updateData.status = customerData.status;

      updateData.updated_at = new Date().toISOString();

      const { data, error } = await supabase
        .from('customers')
        .update(updateData)
        .eq('id', id)
        .select()
        .maybeSingle();

      if (error) {
        logger.error('DB error updating customer:', error);
        throw new Error('Database error');
      }

      if (!data) {
        logger.warn('customers row not found for filter id:', id);
        throw new Error('Customer not found');
      }

      return this.mapCustomerFromDb(data);
    } catch (error: any) {
      logger.error('Error in updateCustomer:', error);
      throw new Error(error.message || 'Failed to update customer');
    }
  }

  /**
   * Delete a customer (soft delete by setting status to inactive)
   */
  static async deleteCustomer(id: string): Promise<void> {
    try {
      const { error } = await supabase
        .from('customers')
        .update({ status: 'inactive', updated_at: new Date().toISOString() })
        .eq('id', id);

      if (error) {
        logger.error('Error deleting customer:', error);
        throw new Error(error.message);
      }
    } catch (error: any) {
      logger.error('Error in deleteCustomer:', error);
      throw new Error(error.message || 'Failed to delete customer');
    }
  }

  /**
   * Map database row to Customer interface
   */
  private static mapCustomerFromDb(customer: any): Customer {
    return {
      id: customer.id,
      code: customer.customer_code,
      name: customer.contact_person,
      email: customer.email,
      phone: customer.phone,
      company: customer.company_name,
      address: {
        street: customer.address_street || '',
        city: customer.address_city || '',
        state: customer.address_state || '',
        pincode: customer.address_pincode || '',
        country: customer.address_country || 'India'
      },
      gstin: customer.gstin || '',
      status: customer.status || 'active',
      created_at: customer.created_at,
      updated_at: customer.updated_at
    };
  }
}
