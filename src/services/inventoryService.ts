// ============================================================================
// INVENTORY SERVICE
// ============================================================================

import { supabase } from '@/lib/supabase';
import { InventoryItem, InventoryItemFormData } from '@/types';
import { getSignedUrl } from './imageService';

class InventoryService {
  /**
   * Get all inventory items (with outlet filtering for non-admin users)
   */
  async getInventoryItems(options?: { outletId?: string }): Promise<InventoryItem[]> {
    try {
      console.log('Fetching inventory items from database...', 'Options:', options);
      let query = supabase
        .from('inventory_items')
        .select('*');

      // Filter by outlet_id if provided (for manager)
      // If outletId is provided, show items for that outlet OR items with NULL outlet_id (shared items)
      if (options?.outletId) {
        // Use PostgREST filter: items matching outlet_id OR items with NULL outlet_id
        // Format: "column.eq.value,column.is.null"
        query = query.or(`outlet_id.eq.${options.outletId},outlet_id.is.null`);
      }
      // If no outletId provided (admin/accountant), show all items including NULL outlet_id

      const { data, error } = await query.order('created_at', { ascending: false });
      
      let itemsData = data;
      
      if (error) {
        console.error('Error in query:', error);
        // If the OR query fails, try fetching all items as fallback
        if (options?.outletId) {
          console.log('Falling back to fetch all items...');
          const { data: allData, error: allError } = await supabase
            .from('inventory_items')
            .select('*')
            .order('created_at', { ascending: false });
          
          if (allError) {
            throw new Error(allError.message);
          }
          
          // Filter client-side: items matching outlet OR NULL outlet_id
          itemsData = (allData || []).filter((item: any) => 
            !item.outlet_id || item.outlet_id === options.outletId
          );
          
          console.log('Fallback fetch - filtered items:', itemsData.length);
        } else {
          throw new Error(error.message);
        }
      }

      console.log('Raw data from database:', itemsData);
      console.log('Number of items found:', itemsData?.length || 0);

      // Map database fields to interface fields - use new schema
      // Also convert storage paths to signed URLs for images
      const mappedItems = await Promise.all((itemsData || []).map(async (item: any) => {
        // Convert image_url from storage path to signed URL if it's a storage path
        let imageUrl = item.image_url;
        let thumbnailUrl = item.thumbnail_url;
        
        // Check if image_url is a storage path (not a full URL)
        if (imageUrl && !imageUrl.startsWith('http') && !imageUrl.startsWith('/')) {
          try {
            const signedResult = await getSignedUrl(imageUrl, 3600); // 1 hour expiry
            if (signedResult.url) {
              imageUrl = signedResult.url;
            }
          } catch (err) {
            console.warn('Failed to get signed URL for image:', imageUrl, err);
            // Keep original path, will show fallback image
          }
        }
        
        // Convert thumbnail_url if it exists and is a storage path
        if (thumbnailUrl && !thumbnailUrl.startsWith('http') && !thumbnailUrl.startsWith('/')) {
          try {
            const signedResult = await getSignedUrl(thumbnailUrl, 3600);
            if (signedResult.url) {
              thumbnailUrl = signedResult.url;
            }
          } catch (err) {
            console.warn('Failed to get signed URL for thumbnail:', thumbnailUrl, err);
            // Keep original path
          }
        }

        return {
          ...item,
          code: item.item_code, // Auto-generated by trigger
          unit_price: item.unit_price || 0,
          location_id: item.outlet_id || 'main-warehouse',
          condition: item.condition || 'excellent',
          last_movement: item.updated_at,
          image_url: imageUrl,
          thumbnail_url: thumbnailUrl || imageUrl
        };
      }));

      console.log('Mapped items:', mappedItems);
      return mappedItems;
    } catch (error: any) {
      console.error('Error in getInventoryItems:', error);
      throw new Error(error.message || 'Failed to fetch inventory items');
    }
  }

  /**
   * Get inventory item by ID
   */
  async getInventoryItem(id: string): Promise<InventoryItem | null> {
    try {
      const { data, error } = await supabase
        .from('inventory_items')
        .select('*')
        .eq('id', id)
        .maybeSingle();

      if (error) {
        console.error('DB error fetching inventory_items:', error);
        throw new Error('Database error');
      }

      if (!data) {
        console.warn('inventory_items row not found for filter id:', id);
        return null;
      }

      // Convert image_url from storage path to signed URL if it's a storage path
      let imageUrl = data.image_url;
      let thumbnailUrl = data.thumbnail_url;
      
      // Check if image_url is a storage path (not a full URL)
      if (imageUrl && !imageUrl.startsWith('http') && !imageUrl.startsWith('/')) {
        try {
          const signedResult = await getSignedUrl(imageUrl, 3600); // 1 hour expiry
          if (signedResult.url) {
            imageUrl = signedResult.url;
          }
        } catch (err) {
          console.warn('Failed to get signed URL for image:', imageUrl, err);
        }
      }
      
      // Convert thumbnail_url if it exists and is a storage path
      if (thumbnailUrl && !thumbnailUrl.startsWith('http') && !thumbnailUrl.startsWith('/')) {
        try {
          const signedResult = await getSignedUrl(thumbnailUrl, 3600);
          if (signedResult.url) {
            thumbnailUrl = signedResult.url;
          }
        } catch (err) {
          console.warn('Failed to get signed URL for thumbnail:', thumbnailUrl, err);
        }
      }

      // Map database fields to interface fields - use new schema
      return {
        ...data,
        code: data.item_code, // Auto-generated by trigger
        unit_price: data.unit_price || 0,
        location_id: data.outlet_id || 'main-warehouse',
        condition: data.condition || 'excellent',
        last_movement: data.updated_at,
        image_url: imageUrl,
        thumbnail_url: thumbnailUrl || imageUrl
      };
    } catch (error: any) {
      console.error('Error in getInventoryItem:', error);
      throw new Error(error.message || 'Failed to fetch inventory item');
    }
  }

  /**
   * Create new inventory item
   */
  async createInventoryItem(itemData: InventoryItemFormData & { outlet_id?: string }): Promise<InventoryItem> {
    try {
      console.log('Creating inventory item with data:', itemData);
      
      // Item code will be auto-generated by database trigger (ITEM-OUTCODE-001)
      
      // Get current user for outlet_id
      const { data: { user } } = await supabase.auth.getUser();
      const outletId = itemData.outlet_id || (user?.user_metadata?.outlet_id);

      // Only insert fields that exist in the database schema
      const insertData: any = {
        // item_code will be auto-generated by trigger
        name: itemData.name,
        description: itemData.description,
        category: itemData.category,
        condition: itemData.condition || 'excellent',
        total_quantity: itemData.total_quantity,
        available_quantity: itemData.available_quantity || itemData.total_quantity,
        reserved_quantity: 0,
        unit_price: itemData.unit_price,
        gst_rate: (itemData as any).gst_rate || 0,
        hsn_code: (itemData as any).hsn_code,
        reorder_point: itemData.reorder_point || 0,
      };

      // Add outlet_id if provided
      if (outletId) {
        insertData.outlet_id = outletId;
      }

      // Add image fields if they exist in the database (from our migration)
      if (itemData.image_url) {
        insertData.image_url = itemData.image_url;
      }
      if (itemData.thumbnail_url) {
        insertData.thumbnail_url = itemData.thumbnail_url;
      }
      if (itemData.image_alt_text) {
        insertData.image_alt_text = itemData.image_alt_text;
      }

      console.log('Insert data prepared:', insertData);

      const { data, error } = await supabase
        .from('inventory_items')
        .insert(insertData)
        .select()
        .maybeSingle();

      if (error) {
        console.error('DB error fetching inventory_items:', error);
        throw new Error('Database error');
      }

      if (!data) {
        console.warn('inventory_items row not found after insert');
        throw new Error('Failed to create inventory item');
      }

      console.log('Item created successfully:', data);

      // Map the response to match our interface
      const mappedItem = {
        ...data,
        code: data.item_code,
        unit_price: data.rental_price_per_day || data.unit_cost || 0,
        location_id: data.location || 'main-warehouse',
        condition: data.condition || 'good',
        last_movement: data.updated_at
      };

      console.log('Mapped item for return:', mappedItem);
      return mappedItem;
    } catch (error: any) {
      console.error('Error in createInventoryItem:', error);
      throw new Error(error.message || 'Failed to create inventory item');
    }
  }

  /**
   * Update inventory item
   */
  async updateInventoryItem(id: string, itemData: Partial<InventoryItemFormData>): Promise<InventoryItem> {
    try {
      const { data, error } = await supabase
        .from('inventory_items')
        .update({
          ...itemData,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .select()
        .maybeSingle();

      if (error) {
        console.error('DB error fetching inventory_items:', error);
        throw new Error('Database error');
      }

      if (!data) {
        console.warn('inventory_items row not found for filter id:', id);
        throw new Error('Inventory item not found');
      }

      return data;
    } catch (error: any) {
      console.error('Error in updateInventoryItem:', error);
      throw new Error(error.message || 'Failed to update inventory item');
    }
  }

  /**
   * Delete inventory item
   */
  async deleteInventoryItem(id: string): Promise<void> {
    try {
      const { error } = await supabase
        .from('inventory_items')
        .delete()
        .eq('id', id);

      if (error) {
        console.error('Error deleting inventory item:', error);
        throw new Error(error.message);
      }
    } catch (error: any) {
      console.error('Error in deleteInventoryItem:', error);
      throw new Error(error.message || 'Failed to delete inventory item');
    }
  }


  /**
   * Update stock quantities
   */
  async updateStock(itemId: string, quantity: number, type: 'add' | 'remove' | 'set'): Promise<void> {
    try {
      const item = await this.getInventoryItem(itemId);
      if (!item) {
        throw new Error('Item not found');
      }

      let newQuantity = item.total_quantity;
      switch (type) {
        case 'add':
          newQuantity += quantity;
          break;
        case 'remove':
          newQuantity = Math.max(0, newQuantity - quantity);
          break;
        case 'set':
          newQuantity = quantity;
          break;
      }

      await this.updateInventoryItem(itemId, {
        total_quantity: newQuantity,
        available_quantity: newQuantity - item.reserved_quantity,
      });
    } catch (error: any) {
      console.error('Error in updateStock:', error);
      throw new Error(error.message || 'Failed to update stock');
    }
  }
}

export default new InventoryService();
