// ============================================================================
// INVENTORY SERVICE
// ============================================================================

import { supabase } from '@/lib/supabase';
import { InventoryItem, InventoryItemFormData } from '@/types';

class InventoryService {
  /**
   * Get all inventory items (with outlet filtering for non-admin users)
   */
  async getInventoryItems(options?: { outletId?: string }): Promise<InventoryItem[]> {
    try {
      console.log('Fetching inventory items from database...');
      let query = supabase
        .from('inventory_items')
        .select('*');

      // Filter by outlet_id if provided (for manager/accountant)
      if (options?.outletId) {
        query = query.eq('outlet_id', options.outletId);
      }

      const { data, error } = await query.order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching inventory items:', error);
        throw new Error(error.message);
      }

      console.log('Raw data from database:', data);
      console.log('Number of items found:', data?.length || 0);

      // Map database fields to interface fields - use new schema
      const mappedItems = (data || []).map((item: any) => ({
        ...item,
        code: item.item_code, // Auto-generated by trigger
        unit_price: item.unit_price || 0,
        location_id: item.outlet_id || 'main-warehouse',
        condition: item.condition || 'excellent',
        last_movement: item.updated_at
      }));

      console.log('Mapped items:', mappedItems);
      return mappedItems;
    } catch (error: any) {
      console.error('Error in getInventoryItems:', error);
      throw new Error(error.message || 'Failed to fetch inventory items');
    }
  }

  /**
   * Get inventory item by ID
   */
  async getInventoryItem(id: string): Promise<InventoryItem | null> {
    try {
      const { data, error } = await supabase
        .from('inventory_items')
        .select('*')
        .eq('id', id)
        .maybeSingle();

      if (error) {
        console.error('DB error fetching inventory_items:', error);
        throw new Error('Database error');
      }

      if (!data) {
        console.warn('inventory_items row not found for filter id:', id);
        return null;
      }

      // Map database fields to interface fields - use new schema
      return {
        ...data,
        code: data.item_code, // Auto-generated by trigger
        unit_price: data.unit_price || 0,
        location_id: data.outlet_id || 'main-warehouse',
        condition: data.condition || 'excellent',
        last_movement: data.updated_at
      };
    } catch (error: any) {
      console.error('Error in getInventoryItem:', error);
      throw new Error(error.message || 'Failed to fetch inventory item');
    }
  }

  /**
   * Create new inventory item
   */
  async createInventoryItem(itemData: InventoryItemFormData & { outlet_id?: string }): Promise<InventoryItem> {
    try {
      console.log('Creating inventory item with data:', itemData);
      
      // Item code will be auto-generated by database trigger (ITEM-OUTCODE-001)
      
      // Get current user for outlet_id
      const { data: { user } } = await supabase.auth.getUser();
      const outletId = itemData.outlet_id || (user?.user_metadata?.outlet_id);

      // Only insert fields that exist in the database schema
      const insertData: any = {
        // item_code will be auto-generated by trigger
        name: itemData.name,
        description: itemData.description,
        category: itemData.category,
        subcategory: itemData.subcategory,
        condition: itemData.condition || 'excellent',
        total_quantity: itemData.total_quantity,
        available_quantity: itemData.available_quantity || itemData.total_quantity,
        reserved_quantity: 0,
        unit_price: itemData.unit_price,
        gst_rate: itemData.gst_rate || 0,
        hsn_code: itemData.hsn_code,
        reorder_point: itemData.reorder_point || 0,
      };

      // Add outlet_id if provided
      if (outletId) {
        insertData.outlet_id = outletId;
      }

      // Add image fields if they exist in the database (from our migration)
      if (itemData.image_url) {
        insertData.image_url = itemData.image_url;
      }
      if (itemData.thumbnail_url) {
        insertData.thumbnail_url = itemData.thumbnail_url;
      }
      if (itemData.image_alt_text) {
        insertData.image_alt_text = itemData.image_alt_text;
      }

      console.log('Insert data prepared:', insertData);

      const { data, error } = await supabase
        .from('inventory_items')
        .insert(insertData)
        .select()
        .maybeSingle();

      if (error) {
        console.error('DB error fetching inventory_items:', error);
        throw new Error('Database error');
      }

      if (!data) {
        console.warn('inventory_items row not found after insert');
        throw new Error('Failed to create inventory item');
      }

      console.log('Item created successfully:', data);

      // Map the response to match our interface
      const mappedItem = {
        ...data,
        code: data.item_code,
        unit_price: data.rental_price_per_day || data.unit_cost || 0,
        location_id: data.location || 'main-warehouse',
        condition: data.condition || 'good',
        last_movement: data.updated_at
      };

      console.log('Mapped item for return:', mappedItem);
      return mappedItem;
    } catch (error: any) {
      console.error('Error in createInventoryItem:', error);
      throw new Error(error.message || 'Failed to create inventory item');
    }
  }

  /**
   * Update inventory item
   */
  async updateInventoryItem(id: string, itemData: Partial<InventoryItemFormData>): Promise<InventoryItem> {
    try {
      const { data, error } = await supabase
        .from('inventory_items')
        .update({
          ...itemData,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .select()
        .maybeSingle();

      if (error) {
        console.error('DB error fetching inventory_items:', error);
        throw new Error('Database error');
      }

      if (!data) {
        console.warn('inventory_items row not found for filter id:', id);
        throw new Error('Inventory item not found');
      }

      return data;
    } catch (error: any) {
      console.error('Error in updateInventoryItem:', error);
      throw new Error(error.message || 'Failed to update inventory item');
    }
  }

  /**
   * Delete inventory item
   */
  async deleteInventoryItem(id: string): Promise<void> {
    try {
      const { error } = await supabase
        .from('inventory_items')
        .delete()
        .eq('id', id);

      if (error) {
        console.error('Error deleting inventory item:', error);
        throw new Error(error.message);
      }
    } catch (error: any) {
      console.error('Error in deleteInventoryItem:', error);
      throw new Error(error.message || 'Failed to delete inventory item');
    }
  }


  /**
   * Update stock quantities
   */
  async updateStock(itemId: string, quantity: number, type: 'add' | 'remove' | 'set'): Promise<void> {
    try {
      const item = await this.getInventoryItem(itemId);
      if (!item) {
        throw new Error('Item not found');
      }

      let newQuantity = item.total_quantity;
      switch (type) {
        case 'add':
          newQuantity += quantity;
          break;
        case 'remove':
          newQuantity = Math.max(0, newQuantity - quantity);
          break;
        case 'set':
          newQuantity = quantity;
          break;
      }

      await this.updateInventoryItem(itemId, {
        total_quantity: newQuantity,
        available_quantity: newQuantity - item.reserved_quantity,
      });
    } catch (error: any) {
      console.error('Error in updateStock:', error);
      throw new Error(error.message || 'Failed to update stock');
    }
  }
}

export default new InventoryService();
