// ============================================================================
// INVOICE SERVICE
// ============================================================================

import { supabase } from '@/lib/supabase';
import { calculateInvoiceFromLines, validateGstRate, LineTaxInput } from '@/lib/invoiceTax';

export interface InvoiceFormData {
  customer_id: string;
  invoice_date: string;
  due_date: string;
  items: InvoiceItemFormData[];
  notes?: string;
}

export interface InvoiceItemFormData {
  description: string;
  quantity: number;
  rate: number;
  gst_rate: number;
  hsn_code?: string;
}

export interface Invoice {
  id: string;
  invoice_number: string;
  customer_id: string;
  customer_name?: string;
  invoice_date: string;
  due_date: string;
  subtotal: number;
  taxable_value: number;
  cgst: number;
  sgst: number;
  igst: number;
  total_gst: number;
  total_amount: number;
  payment_status: string;
  payment_received?: number;
  invoice_pdf_url?: string;
  invoice_pdf_key?: string;
  notes?: string;
  created_at: string;
  updated_at: string;
  items: InvoiceItemFormData[];
}

export class InvoiceService {
  /**
   * Create a new invoice
   */
  static async createInvoice(invoiceData: InvoiceFormData & { outlet_id?: string; outletState?: string; customerState?: string }): Promise<Invoice> {
    try {
      // Invoice number will be auto-generated by database trigger (INVOICE-OUTCODE-001)
      
      // Get current user for outlet_id and created_by
      const { data: { user } } = await supabase.auth.getUser();
      const outletId = invoiceData.outlet_id || (user?.user_metadata?.outlet_id);

      // Validate GST rates
      for (const item of invoiceData.items) {
        const validation = validateGstRate(item.gst_rate);
        if (!validation.isValid) {
          throw new Error(`Invalid GST rate for item "${item.description}": ${validation.message}`);
        }
      }

      // Convert items to tax calculation format
      const taxLines: LineTaxInput[] = invoiceData.items.map(item => ({
        qty: item.quantity,
        rate: item.rate,
        gstRate: item.gst_rate,
        ...(invoiceData.outletState && { outletState: invoiceData.outletState }),
        ...(invoiceData.customerState && { customerState: invoiceData.customerState })
      }));

      // Calculate tax totals using the tax engine
      const taxResult = calculateInvoiceFromLines(taxLines, 'DOMESTIC', invoiceData.outletState, invoiceData.customerState);

      const insertData: any = {
        // invoice_number will be auto-generated by trigger
        customer_id: invoiceData.customer_id,
        invoice_date: invoiceData.invoice_date,
        due_date: invoiceData.due_date,
        subtotal: taxResult.taxable_value, // Legacy field for compatibility
        taxable_value: taxResult.taxable_value,
        cgst: taxResult.cgst,
        sgst: taxResult.sgst,
        igst: taxResult.igst,
        total_gst: taxResult.cgst + taxResult.sgst + taxResult.igst,
        total_amount: taxResult.total_amount,
        payment_status: 'pending',
        notes: invoiceData.notes || null,
        created_by: user?.id
      };

      // Add outlet_id if provided
      if (outletId) {
        insertData.outlet_id = outletId;
      }

      const { data, error } = await supabase
        .from('invoices')
        .insert(insertData)
        .select()
        .maybeSingle();

      if (error) {
        console.error('DB error fetching invoices:', error);
        throw new Error('Database error');
      }

      if (!data) {
        console.warn('invoices row not found after insert');
        throw new Error('Failed to create invoice');
      }

      // Create invoice items
      if (invoiceData.items.length > 0) {
        const invoiceItems = invoiceData.items.map((item, index) => ({
          invoice_id: data.id,
          description: item.description,
          quantity: item.quantity,
          rate: item.rate,
          gst_rate: item.gst_rate,
          hsn_code: item.hsn_code || null,
          total_amount: taxResult.breakdown[index]?.lineTotal || (item.quantity * item.rate * (1 + item.gst_rate / 100))
        }));

        const { error: itemsError } = await supabase
          .from('invoice_items')
          .insert(invoiceItems);

        if (itemsError) {
          console.error('Error creating invoice items:', itemsError);
          throw new Error(itemsError.message);
        }
      }

      return {
        ...data,
        items: invoiceData.items
      };
    } catch (error: any) {
      console.error('Error in createInvoice:', error);
      throw new Error(error.message || 'Failed to create invoice');
    }
  }

  /**
   * Get all invoices (with outlet filtering for non-admin users)
   */
  static async getInvoices(outletId?: string): Promise<Invoice[]> {
    try {
      let query = supabase
        .from('invoices')
        .select(`
          *,
          customers(contact_person),
          invoice_items(*)
        `);

      // Filter by outlet_id if provided (for manager/accountant)
      if (outletId) {
        query = query.eq('outlet_id', outletId);
      }

      const { data, error } = await query.order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching invoices:', error);
        throw new Error(error.message);
      }

      return (data || []).map((invoice: any) => ({
        id: invoice.id,
        invoice_number: invoice.invoice_number,
        customer_id: invoice.customer_id,
        customer_name: invoice.customers?.contact_person,
        invoice_date: invoice.invoice_date,
        due_date: invoice.due_date,
        subtotal: invoice.subtotal,
        taxable_value: invoice.taxable_value || invoice.subtotal || 0,
        cgst: invoice.cgst || 0,
        sgst: invoice.sgst || 0,
        igst: invoice.igst || 0,
        total_gst: invoice.total_gst,
        total_amount: invoice.total_amount,
        payment_status: invoice.payment_status,
        payment_received: Number(invoice.payment_received || 0),
        invoice_pdf_url: invoice.invoice_pdf_url,
        invoice_pdf_key: invoice.invoice_pdf_key,
        notes: invoice.notes,
        created_at: invoice.created_at,
        updated_at: invoice.updated_at,
        items: invoice.invoice_items || []
      }));
    } catch (error: any) {
      console.error('Error in getInvoices:', error);
      throw new Error(error.message || 'Failed to fetch invoices');
    }
  }

  /**
   * Get a single invoice by ID
   */
  static async getInvoice(id: string): Promise<Invoice> {
    try {
      const { data, error } = await supabase
        .from('invoices')
        .select(`
          *,
          customers(contact_person),
          invoice_items(*)
        `)
        .eq('id', id)
        .maybeSingle();

      if (error) {
        console.error('DB error fetching invoices:', error);
        throw new Error('Database error');
      }

      if (!data) {
        console.warn('invoices row not found for filter id:', id);
        throw new Error('Invoice not found');
      }

        return {
          id: data.id,
          invoice_number: data.invoice_number,
          customer_id: data.customer_id,
          customer_name: data.customers?.contact_person,
          invoice_date: data.invoice_date,
          due_date: data.due_date,
          subtotal: data.subtotal,
          taxable_value: data.taxable_value || data.subtotal,
          cgst: data.cgst || 0,
          sgst: data.sgst || 0,
          igst: data.igst || 0,
          total_gst: data.total_gst,
          total_amount: data.total_amount,
          payment_status: data.payment_status,
          payment_received: Number(data.payment_received || 0),
          invoice_pdf_url: data.invoice_pdf_url,
          invoice_pdf_key: data.invoice_pdf_key,
          notes: data.notes,
          created_at: data.created_at,
          updated_at: data.updated_at,
          items: data.invoice_items || []
        };
    } catch (error: any) {
      console.error('Error in getInvoice:', error);
      throw new Error(error.message || 'Failed to fetch invoice');
    }
  }

  /**
   * Create a payment for an invoice
   */
  static async createPayment(paymentData: {
    invoice_id: string;
    amount: number;
    method: string;
    outlet_id?: string;
    reference_number?: string;
    notes?: string;
  }): Promise<{ payment: any; invoice: any }> {
    try {
      // Get current user for created_by
      const { data: { user } } = await supabase.auth.getUser();
      
      // Get invoice to determine outlet_id and customer_id
      const invoice = await this.getInvoice(paymentData.invoice_id);
      
      const insertData: any = {
        // payment_number will be auto-generated by trigger (PAY-OUTCODE-001)
        invoice_id: paymentData.invoice_id,
        customer_id: invoice.customer_id,
        amount: paymentData.amount,
        payment_method: paymentData.method,
        payment_date: new Date().toISOString().split('T')[0],
        reference_number: paymentData.reference_number,
        notes: paymentData.notes,
        created_by: user?.id
      };

      // Add outlet_id
      const outletId = paymentData.outlet_id;
      if (outletId) {
        insertData.outlet_id = outletId;
      }

      const { data, error } = await supabase
        .from('payments')
        .insert(insertData)
        .select()
        .maybeSingle();

      if (error) {
        console.error('DB error creating payment:', error);
        throw new Error('Database error');
      }

      if (!data) {
        throw new Error('Failed to create payment');
      }

      // Refetch invoice to get updated payment_received
      const updatedInvoice = await supabase
        .from('invoices')
        .select('*')
        .eq('id', paymentData.invoice_id)
        .maybeSingle();

      return { payment: data, invoice: updatedInvoice.data };
    } catch (error: any) {
      console.error('Error in createPayment:', error);
      throw new Error(error.message || 'Failed to create payment');
    }
  }
}
