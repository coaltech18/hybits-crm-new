// ============================================================================
// INVOICE SERVICE
// ============================================================================

import { supabase } from '@/lib/supabase';

export interface InvoiceFormData {
  customer_id: string;
  invoice_date: string;
  due_date: string;
  items: InvoiceItemFormData[];
  notes?: string;
}

export interface InvoiceItemFormData {
  description: string;
  quantity: number;
  rate: number;
  gst_rate: number;
}

export interface Invoice {
  id: string;
  invoice_number: string;
  customer_id: string;
  customer_name?: string;
  invoice_date: string;
  due_date: string;
  subtotal: number;
  total_gst: number;
  total_amount: number;
  payment_status: string;
  notes?: string;
  created_at: string;
  updated_at: string;
  items: InvoiceItemFormData[];
}

export class InvoiceService {
  /**
   * Create a new invoice
   */
  static async createInvoice(invoiceData: InvoiceFormData & { outlet_id?: string }): Promise<Invoice> {
    try {
      // Invoice number will be auto-generated by database trigger (INVOICE-OUTCODE-001)
      
      // Get current user for outlet_id and created_by
      const { data: { user } } = await supabase.auth.getUser();
      const outletId = invoiceData.outlet_id || (user?.user_metadata?.outlet_id);

      // Calculate totals
      const subtotal = invoiceData.items.reduce((sum, item) => sum + (item.quantity * item.rate), 0);
      const totalGst = invoiceData.items.reduce((sum, item) => {
        const itemTotal = item.quantity * item.rate;
        return sum + (itemTotal * item.gst_rate / 100);
      }, 0);
      const totalAmount = subtotal + totalGst;

      const insertData: any = {
        // invoice_number will be auto-generated by trigger
        customer_id: invoiceData.customer_id,
        invoice_date: invoiceData.invoice_date,
        due_date: invoiceData.due_date,
        subtotal: subtotal,
        total_gst: totalGst,
        total_amount: totalAmount,
        payment_status: 'pending',
        notes: invoiceData.notes || null,
        created_by: user?.id
      };

      // Add outlet_id if provided
      if (outletId) {
        insertData.outlet_id = outletId;
      }

      const { data, error } = await supabase
        .from('invoices')
        .insert(insertData)
        .select()
        .maybeSingle();

      if (error) {
        console.error('DB error fetching invoices:', error);
        throw new Error('Database error');
      }

      if (!data) {
        console.warn('invoices row not found after insert');
        throw new Error('Failed to create invoice');
      }

      // Create invoice items
      if (invoiceData.items.length > 0) {
        const invoiceItems = invoiceData.items.map(item => ({
          invoice_id: data.id,
          description: item.description,
          quantity: item.quantity,
          rate: item.rate,
          gst_rate: item.gst_rate,
          total_amount: (item.quantity * item.rate) + (item.quantity * item.rate * item.gst_rate / 100)
        }));

        const { error: itemsError } = await supabase
          .from('invoice_items')
          .insert(invoiceItems);

        if (itemsError) {
          console.error('Error creating invoice items:', itemsError);
          throw new Error(itemsError.message);
        }
      }

      return {
        ...data,
        items: invoiceData.items
      };
    } catch (error: any) {
      console.error('Error in createInvoice:', error);
      throw new Error(error.message || 'Failed to create invoice');
    }
  }

  /**
   * Get all invoices (with outlet filtering for non-admin users)
   */
  static async getInvoices(outletId?: string): Promise<Invoice[]> {
    try {
      let query = supabase
        .from('invoices')
        .select(`
          *,
          customers(contact_person),
          invoice_items(*)
        `);

      // Filter by outlet_id if provided (for manager/accountant)
      if (outletId) {
        query = query.eq('outlet_id', outletId);
      }

      const { data, error } = await query.order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching invoices:', error);
        throw new Error(error.message);
      }

      return (data || []).map((invoice: any) => ({
        id: invoice.id,
        invoice_number: invoice.invoice_number,
        customer_id: invoice.customer_id,
        customer_name: invoice.customers?.contact_person,
        invoice_date: invoice.invoice_date,
        due_date: invoice.due_date,
        subtotal: invoice.subtotal,
        total_gst: invoice.total_gst,
        total_amount: invoice.total_amount,
        payment_status: invoice.payment_status,
        notes: invoice.notes,
        created_at: invoice.created_at,
        updated_at: invoice.updated_at,
        items: invoice.invoice_items || []
      }));
    } catch (error: any) {
      console.error('Error in getInvoices:', error);
      throw new Error(error.message || 'Failed to fetch invoices');
    }
  }

  /**
   * Get a single invoice by ID
   */
  static async getInvoice(id: string): Promise<Invoice> {
    try {
      const { data, error } = await supabase
        .from('invoices')
        .select(`
          *,
          customers(contact_person),
          invoice_items(*)
        `)
        .eq('id', id)
        .maybeSingle();

      if (error) {
        console.error('DB error fetching invoices:', error);
        throw new Error('Database error');
      }

      if (!data) {
        console.warn('invoices row not found for filter id:', id);
        throw new Error('Invoice not found');
      }

      return {
        id: data.id,
        invoice_number: data.invoice_number,
        customer_id: data.customer_id,
        customer_name: data.customers?.contact_person,
        invoice_date: data.invoice_date,
        due_date: data.due_date,
        subtotal: data.subtotal,
        total_gst: data.total_gst,
        total_amount: data.total_amount,
        payment_status: data.payment_status,
        notes: data.notes,
        created_at: data.created_at,
        updated_at: data.updated_at,
        items: data.invoice_items || []
      };
    } catch (error: any) {
      console.error('Error in getInvoice:', error);
      throw new Error(error.message || 'Failed to fetch invoice');
    }
  }

  /**
   * Create a payment for an invoice
   */
  static async createPayment(paymentData: {
    invoice_id: string;
    amount: number;
    method: string;
    outlet_id?: string;
    reference_number?: string;
    notes?: string;
  }): Promise<{ payment: any; invoice: any }> {
    try {
      // Get current user for created_by
      const { data: { user } } = await supabase.auth.getUser();
      
      // Get invoice to determine outlet_id and customer_id
      const invoice = await this.getInvoice(paymentData.invoice_id);
      
      const insertData: any = {
        // payment_number will be auto-generated by trigger (PAY-OUTCODE-001)
        invoice_id: paymentData.invoice_id,
        customer_id: invoice.customer_id,
        amount: paymentData.amount,
        payment_method: paymentData.method,
        payment_date: new Date().toISOString().split('T')[0],
        reference_number: paymentData.reference_number,
        notes: paymentData.notes,
        created_by: user?.id
      };

      // Add outlet_id
      const outletId = paymentData.outlet_id;
      if (outletId) {
        insertData.outlet_id = outletId;
      }

      const { data, error } = await supabase
        .from('payments')
        .insert(insertData)
        .select()
        .maybeSingle();

      if (error) {
        console.error('DB error creating payment:', error);
        throw new Error('Database error');
      }

      if (!data) {
        throw new Error('Failed to create payment');
      }

      // Refetch invoice to get updated payment_received
      const updatedInvoice = await supabase
        .from('invoices')
        .select('*')
        .eq('id', paymentData.invoice_id)
        .maybeSingle();

      return { payment: data, invoice: updatedInvoice.data };
    } catch (error: any) {
      console.error('Error in createPayment:', error);
      throw new Error(error.message || 'Failed to create payment');
    }
  }
}
