// ============================================================================
// ORDER SERVICE
// ============================================================================

import { supabase } from '@/lib/supabase';
import { Order, OrderStatus } from '@/types';
import { calculateInvoiceFromLines, LineTaxInput, roundToTwoDecimals } from '@/lib/invoiceTax';
import { Invoice } from '@/services/invoiceService';

// Helper function for exponential backoff delay
const sleep = (ms: number): Promise<void> => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

const MAX_INVOICE_CREATION_ATTEMPTS = 3;

export interface OrderFormData {
  customer_id: string;
  event_date: string;
  event_type: 'wedding' | 'corporate' | 'birthday' | 'anniversary' | 'other';
  event_duration: number;
  guest_count: number;
  location_type: 'indoor' | 'outdoor' | 'both';
  items: OrderItemFormData[];
  status: 'pending' | 'confirmed' | 'items_dispatched' | 'items_returned' | 'completed' | 'cancelled';
  notes?: string;
}

export interface OrderItemFormData {
  item_id: string;
  quantity: number;
  rate: number;
}


export class OrderService {
  /**
   * Create a new order
   */
  static async createOrder(orderData: OrderFormData & { outlet_id?: string }): Promise<Order> {
    try {
      // Order number will be auto-generated by database trigger (ORD-OUTCODE-001)
      
      // Get current user for outlet_id and created_by
      const { data: { user } } = await supabase.auth.getUser();
      const outletId = orderData.outlet_id || (user?.user_metadata?.outlet_id);

      // Calculate order GST amount using tax engine
      let computedOrderGst = 0;
      try {
        if (orderData.items.length > 0) {
          const taxLines: LineTaxInput[] = orderData.items.map(item => ({
            qty: Number(item.quantity || 1),
            rate: Number(item.rate || 0),
            gstRate: (item as any).gst_rate !== undefined ? Number((item as any).gst_rate) : 18,
            outletState: '', // Empty for order-level quick calc without DB fetch
            customerState: ''
          }));
          const taxResult = calculateInvoiceFromLines(taxLines, 'DOMESTIC');
          computedOrderGst = roundToTwoDecimals((taxResult.cgst || 0) + (taxResult.sgst || 0) + (taxResult.igst || 0));
        }
      } catch (err) {
        console.warn('Order GST compute failed â€” proceeding with gst_amount=0', err);
        computedOrderGst = 0;
      }

      const insertData: any = {
        // order_number will be auto-generated by trigger
        customer_id: orderData.customer_id,
        event_date: orderData.event_date,
        delivery_date: (orderData as any).delivery_date || orderData.event_date,
        return_date: (orderData as any).return_date || orderData.event_date,
        event_type: orderData.event_type,
        event_duration: orderData.event_duration || 0,
        guest_count: orderData.guest_count || 0,
        location_type: orderData.location_type,
        total_amount: orderData.items.reduce((sum, item) => sum + (item.quantity * item.rate), 0),
        security_deposit: (orderData as any).security_deposit || 0,
        gst_amount: computedOrderGst,
        status: orderData.status || 'pending',
        payment_status: 'pending',
        notes: orderData.notes || null,
        created_by: user?.id
      };

      // Add outlet_id if provided
      if (outletId) {
        insertData.outlet_id = outletId;
      }

      const { data, error } = await supabase
        .from('rental_orders')
        .insert(insertData)
        .select('id, order_number, customer_id, event_date, event_type, event_duration, guest_count, location_type, status, payment_status, total_amount, notes, created_at, updated_at')
        .maybeSingle();

      if (error) {
        console.error('DB error creating rental_orders:', error);
        console.error('Error details:', JSON.stringify(error, null, 2));
        throw new Error(error.message || 'Database error: ' + (error.details || error.hint || 'Unknown error'));
      }

      if (!data) {
        console.warn('rental_orders row not found after insert');
        throw new Error('Failed to create order');
      }

      // Create order items
      if (orderData.items.length > 0) {
        const orderItems = orderData.items.map(item => ({
          order_id: data.id,
          item_id: item.item_id,
          quantity: item.quantity,
          rental_days: (item as any).rental_days || 1,
          unit_price: item.rate,
          total_price: item.quantity * ((item as any).rental_days || 1) * item.rate,
          gst_rate: (item as any).gst_rate !== undefined ? (item as any).gst_rate : 18 // Default 18%
        }));

        const { error: itemsError } = await supabase
          .from('rental_order_items')
          .insert(orderItems);

        if (itemsError) {
          console.error('Error creating order items:', itemsError);
          throw new Error(itemsError.message);
        }

        // --- START: Order -> Invoice using tax engine with retry and audit ---
        const currentOutletId = outletId;
        const currentCustomerId = data.customer_id;
        const currentUserId = user?.id;
        const orderId = data.id;

        // Helper function to attempt invoice creation
        const attemptCreateInvoice = async (_attemptNumber: number): Promise<any> => {
          // Fetch inventory item names for invoice descriptions
          const itemIds = orderData.items.map(item => item.item_id);
          const { data: inventoryItems, error: inventoryError } = await supabase
            .from('inventory_items')
            .select('id, name')
            .in('id', itemIds);

          if (inventoryError) {
            console.warn('Error fetching inventory items for invoice:', inventoryError);
          }

          // Create a map of item_id to item_name
          const itemNameMap = new Map<string, string>();
          (inventoryItems || []).forEach((item: any) => {
            itemNameMap.set(item.id, item.name || 'Unknown Item');
          });

          // Fetch outlet state
          let outletState: string | undefined;
          if (currentOutletId) {
            const { data: outletData, error: outletErr } = await supabase
              .from('locations')
              .select('address')
              .eq('id', currentOutletId)
              .single();
            if (outletErr) {
              console.warn('Could not fetch outlet location for tax calculation', outletErr);
            } else {
              outletState = outletData?.address?.state;
            }
          }

          // Fetch customer state
          let customerState: string | undefined;
          if (currentCustomerId) {
            const { data: customerData, error: custErr } = await supabase
              .from('customers')
              .select('address')
              .eq('id', currentCustomerId)
              .single();
            if (custErr) {
              console.warn('Could not fetch customer address for tax calculation', custErr);
            } else {
              customerState = customerData?.address?.state;
            }
          }

          // Build tax lines using order items
          const taxLines: LineTaxInput[] = orderItems.map((it: any) => ({
            qty: Number(it.quantity) || 1,
            rate: Number(it.unit_price) || 0,
            gstRate: typeof it.gst_rate !== 'undefined' ? Number(it.gst_rate) : 18, // default 18%
            outletState: outletState || '',
            customerState: customerState || ''
          }));

          // Central tax calculation
          const taxResult = calculateInvoiceFromLines(taxLines, 'DOMESTIC', outletState, customerState);

          // Calculate invoice dates
          const invoiceDate = new Date().toISOString().split('T')[0]; // Today's date
          const eventDateObj = new Date(orderData.event_date);
          // Due date: 30 days from invoice date, or event date + 7 days, whichever is later
          const dueDateObj = new Date(eventDateObj);
          dueDateObj.setDate(dueDateObj.getDate() + 7);
          const defaultDueDate = new Date();
          defaultDueDate.setDate(defaultDueDate.getDate() + 30);
          const dueDate = dueDateObj > defaultDueDate 
            ? dueDateObj.toISOString().split('T')[0]
            : defaultDueDate.toISOString().split('T')[0];

          // Prepare invoice payload
          const invoicePayload: any = {
            order_id: orderId,
            customer_id: currentCustomerId,
            invoice_date: invoiceDate,
            due_date: dueDate,
            invoice_type: 'rental',
            subtotal: roundToTwoDecimals(taxResult.taxable_value), // Legacy field for compatibility
            taxable_value: roundToTwoDecimals(taxResult.taxable_value),
            cgst: roundToTwoDecimals(taxResult.cgst),
            sgst: roundToTwoDecimals(taxResult.sgst),
            igst: roundToTwoDecimals(taxResult.igst),
            total_gst: roundToTwoDecimals(taxResult.cgst + taxResult.sgst + taxResult.igst), // Legacy field
            total_amount: roundToTwoDecimals(taxResult.total_amount),
            payment_status: 'pending',
            notes: orderData.notes || `Invoice for order ${data.order_number}`,
            created_by: currentUserId || null
          };

          // Add outlet_id if available
          if (currentOutletId) {
            invoicePayload.outlet_id = currentOutletId;
          }

          const { data: invoiceData, error: invoiceErr } = await supabase
            .from('invoices')
            .insert(invoicePayload)
            .select()
            .single();

          if (invoiceErr || !invoiceData) {
            throw invoiceErr || new Error('Invoice creation returned no data');
          }

          // Prepare invoice items from taxResult.breakdown
          const invoiceItemsToInsert = taxResult.breakdown.map((line, index) => {
            const orderItem = orderItems[index];
            const itemName = orderItem ? itemNameMap.get(orderItem.item_id) || 'Rental Item' : 'Rental Item';
            const rentalDays = (orderItem as any)?.rental_days || 1;
            const quantity = orderItem ? orderItem.quantity * rentalDays : taxLines[index]?.qty || 1;
            
            return {
              invoice_id: invoiceData.id,
              description: itemName,
              quantity: roundToTwoDecimals(quantity),
              rate: roundToTwoDecimals(taxLines[index]?.rate || 0),
              gst_rate: taxLines[index]?.gstRate || 18,
              amount: roundToTwoDecimals(line.taxable), // Base amount (taxable value before GST)
              hsn_code: null // Can be added later if needed
            };
          });

          if (invoiceItemsToInsert.length > 0) {
            const { error: invItemsErr } = await supabase
              .from('invoice_items')
              .insert(invoiceItemsToInsert);
            if (invItemsErr) {
              console.error('Failed to insert invoice items for invoice', invoiceData.id, invItemsErr);
              // Cleanup - attempt to delete invoice to avoid orphan invoice
              await supabase.from('invoices').delete().eq('id', invoiceData.id);
              throw invItemsErr;
            }
          }

          return { success: true, invoice: invoiceData };
        };

        // Retry logic with exponential backoff and audit
        let lastErr: any = null;
        let createdInvoice: any = null;

        for (let attempt = 1; attempt <= MAX_INVOICE_CREATION_ATTEMPTS; attempt++) {
          try {
            const result = await attemptCreateInvoice(attempt);
            createdInvoice = result.invoice;

            // Write audit success record
            await supabase.from('invoice_creation_audit').insert({
              order_id: orderId,
              invoice_id: createdInvoice.id,
              outlet_id: currentOutletId || null,
              requester_id: currentUserId || null,
              attempt_integer: attempt,
              success: true,
              error_message: null,
              metadata: { source: 'orderService.createOrder', order_number: data.order_number }
            });

            console.log(`Invoice ${createdInvoice.id} created successfully for order ${data.order_number} (attempt ${attempt})`);
            break;
          } catch (err: any) {
            lastErr = err;

            // Write audit failure record
            await supabase.from('invoice_creation_audit').insert({
              order_id: orderId,
              invoice_id: null,
              outlet_id: currentOutletId || null,
              requester_id: currentUserId || null,
              attempt_integer: attempt,
              success: false,
              error_message: err?.message ? String(err.message) : String(err),
              metadata: { 
                attempt, 
                timestamp: new Date().toISOString(),
                source: 'orderService.createOrder',
                order_number: data.order_number
              }
            });

            // Exponential backoff (except on last attempt)
            if (attempt < MAX_INVOICE_CREATION_ATTEMPTS) {
              const backoffMs = Math.pow(2, attempt) * 200; // 400ms, 800ms, 1600ms
              await sleep(backoffMs);
            }
          }
        }

        if (!createdInvoice) {
          // After all retries failed, throw clear error
          throw new Error(`Invoice creation failed after ${MAX_INVOICE_CREATION_ATTEMPTS} attempts: ${lastErr?.message || lastErr}`);
        }
        // --- END: Order -> Invoice using tax engine with retry and audit ---
      }

      return {
        id: data.id,
        order_number: data.order_number,
        customer_id: data.customer_id,
        customer_name: '', // Will be populated when fetching with joins
        event_date: data.event_date,
        event_type: data.event_type || 'other', // Default value if column doesn't exist
        event_duration: data.event_duration || 0, // Default value if column doesn't exist
        guest_count: data.guest_count || 0, // Default value if column doesn't exist
        location_type: data.location_type || 'indoor', // Default value if column doesn't exist
        status: data.status,
        payment_status: data.payment_status || 'pending',
        total_amount: data.total_amount || 0,
        notes: data.notes,
        created_at: data.created_at,
        updated_at: data.updated_at,
        items: orderData.items.map((item, index) => ({
          id: `temp-${index}`,
          item_id: item.item_id,
          item_name: 'Unknown Item', // Will be populated when fetching with joins
          quantity: item.quantity,
          rate: item.rate,
          rental_days: (item as any).rental_days || 1,
          amount: item.quantity * ((item as any).rental_days || 1) * item.rate
        }))
      };
    } catch (error: any) {
      console.error('Error in createOrder:', error);
      throw new Error(error.message || 'Failed to create order');
    }
  }

  /**
   * Get all orders (with outlet filtering for non-admin users)
   */
  static async getOrders(outletId?: string): Promise<Order[]> {
    try {
      let query = supabase
        .from('rental_orders')
        .select(`
          *,
          customers(contact_person),
          rental_order_items(
            *,
            inventory_items(name, item_code, unit_price)
          )
        `);

      // Filter by outlet_id if provided (for manager/accountant)
      if (outletId) {
        query = query.eq('outlet_id', outletId);
      }

      const { data, error } = await query.order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching orders:', error);
        throw new Error(error.message);
      }

      return (data || []).map((order: any) => ({
        id: order.id,
        order_number: order.order_number,
        customer_id: order.customer_id,
        customer_name: order.customers?.contact_person || '',
        event_date: order.event_date,
        event_type: order.event_type || 'other', // Default value if column doesn't exist
        event_duration: order.event_duration || 0, // Default value if column doesn't exist
        guest_count: order.guest_count || 0, // Default value if column doesn't exist
        location_type: order.location_type || 'indoor', // Default value if column doesn't exist
        status: order.status,
        payment_status: order.payment_status || 'pending',
        total_amount: order.total_amount || 0,
        notes: order.notes,
        created_at: order.created_at,
        updated_at: order.updated_at,
        items: (order.rental_order_items || []).map((item: any) => ({
          id: item.id,
          item_id: item.item_id,
          item_name: item.inventory_items?.name || item.item_name || 'Unknown Item',
          quantity: item.quantity,
          rate: item.unit_price || item.rate,
          rental_days: (item as any).rental_days || 1,
          amount: item.total_price || (item.quantity * (item.rental_days || 1) * (item.unit_price || item.rate))
        }))
      }));
    } catch (error: any) {
      console.error('Error in getOrders:', error);
      throw new Error(error.message || 'Failed to fetch orders');
    }
  }

  /**
   * Get a single order by ID
   */
  static async getOrder(id: string): Promise<Order> {
    try {
      const { data, error } = await supabase
        .from('rental_orders')
        .select(`
          *,
          customers(contact_person),
          rental_order_items(
            *,
            inventory_items(name, item_code)
          )
        `)
        .eq('id', id)
        .maybeSingle();

      if (error) {
        console.error('DB error fetching rental_orders:', error);
        throw new Error('Database error');
      }

      if (!data) {
        console.warn('rental_orders row not found for filter id:', id);
        throw new Error('Order not found');
      }

      return {
        id: data.id,
        order_number: data.order_number,
        customer_id: data.customer_id,
        customer_name: data.customers?.contact_person || '',
        event_date: data.event_date,
        event_type: data.event_type || 'other', // Default value if column doesn't exist
        event_duration: data.event_duration || 0, // Default value if column doesn't exist
        guest_count: data.guest_count || 0, // Default value if column doesn't exist
        location_type: data.location_type || 'indoor', // Default value if column doesn't exist
        status: data.status,
        payment_status: data.payment_status || 'pending',
        total_amount: data.total_amount || 0,
        notes: data.notes,
        created_at: data.created_at,
        updated_at: data.updated_at,
        items: (data.rental_order_items || []).map((item: any) => ({
          id: item.id,
          item_id: item.item_id,
          item_name: item.inventory_items?.name || 'Unknown Item',
          quantity: item.quantity,
          rate: item.rate,
          amount: item.quantity * item.rate
        }))
      };
    } catch (error: any) {
      console.error('Error in getOrder:', error);
      throw new Error(error.message || 'Failed to fetch order');
    }
  }

  /**
   * Update order status
   */
  static async updateOrderStatus(id: string, status: OrderStatus): Promise<Order> {
    try {
      console.log(`Updating order ${id} status to ${status}`);
      
      const { data, error } = await supabase
        .from('rental_orders')
        .update({ 
          status,
          updated_at: new Date().toISOString()
        })
        .eq('id', id)
        .select(`
          *,
          customers:customer_id (
            contact_person,
            email,
            phone
          ),
          rental_order_items (
            *,
            inventory_items:item_id (
              name,
              unit_price,
              item_code
            )
          )
        `)
        .maybeSingle();

      if (error) {
        console.error('DB error fetching rental_orders:', error);
        throw new Error('Database error');
      }

      if (!data) {
        console.warn('rental_orders row not found for filter id:', id);
        throw new Error('Order not found');
      }

      return {
        id: data.id,
        order_number: data.order_number,
        customer_id: data.customer_id,
        customer_name: data.customers?.contact_person || '',
        event_date: data.event_date,
        event_type: data.event_type || 'other',
        event_duration: data.event_duration || 0,
        guest_count: data.guest_count || 0,
        location_type: data.location_type || 'indoor',
        status: data.status,
        payment_status: data.payment_status || 'pending',
        total_amount: data.total_amount || 0,
        notes: data.notes,
        created_at: data.created_at,
        updated_at: data.updated_at,
        items: (data.rental_order_items || []).map((item: any) => ({
          id: item.id,
          item_id: item.item_id,
          item_name: item.inventory_items?.name || item.item_name || 'Unknown Item',
          quantity: item.quantity,
          rate: item.unit_price || item.rate,
          rental_days: (item as any).rental_days || 1,
          amount: item.total_price || (item.quantity * (item.rental_days || 1) * (item.unit_price || item.rate))
        }))
      };
    } catch (error: any) {
      console.error('Error in updateOrderStatus:', error);
      throw new Error(error.message || 'Failed to update order status');
    }
  }

  /**
   * Add items to an order
   */
  static async addOrderItems(orderId: string, items: OrderItemFormData[]): Promise<void> {
    try {
      console.log(`Adding ${items.length} items to order ${orderId}`);
      
      const orderItems = items.map(item => ({
        order_id: orderId,
        item_id: item.item_id,
        quantity: item.quantity,
        rate: item.rate,
        rental_days: 1, // Default to 1 day, can be calculated based on event duration
        total_price: item.quantity * item.rate
      }));

      const { error } = await supabase
        .from('rental_order_items')
        .insert(orderItems);

      if (error) {
        console.error('Error adding order items:', error);
        throw new Error(error.message);
      }

      // Update total amount
      const totalAmount = items.reduce((sum, item) => sum + (item.quantity * item.rate), 0);
      await supabase
        .from('rental_orders')
        .update({ 
          total_amount: totalAmount,
          updated_at: new Date().toISOString()
        })
        .eq('id', orderId);

    } catch (error: any) {
      console.error('Error in addOrderItems:', error);
      throw new Error(error.message || 'Failed to add order items');
    }
  }

  /**
   * Recreate invoice for an existing order
   * Used for manual retry when invoice creation failed
   */
  static async recreateInvoiceForOrder(orderId: string): Promise<Invoice> {
    try {
      // Get current user for outlet_id and created_by
      const { data: { user } } = await supabase.auth.getUser();
      
      // Fetch the order
      const order = await this.getOrder(orderId);
      if (!order) {
        throw new Error('Order not found');
      }

      // Check if invoice already exists
      const { data: existingInvoice } = await supabase
        .from('invoices')
        .select('id')
        .eq('order_id', orderId)
        .maybeSingle();

      if (existingInvoice) {
        throw new Error('Invoice already exists for this order');
      }

      // Get outlet ID
      const { data: orderData } = await supabase
        .from('rental_orders')
        .select('outlet_id, customer_id, event_date, notes, order_number')
        .eq('id', orderId)
        .single();

      if (!orderData) {
        throw new Error('Order data not found');
      }

      // Get order items
      const { data: orderItemsData } = await supabase
        .from('rental_order_items')
        .select('*')
        .eq('order_id', orderId);

      if (!orderItemsData || orderItemsData.length === 0) {
        throw new Error('Order has no items');
      }

      // Prepare order data for invoice creation
      const orderFormData: OrderFormData = {
        customer_id: orderData.customer_id,
        event_date: order.event_date,
        event_type: order.event_type || 'other',
        event_duration: order.event_duration || 0,
        guest_count: order.guest_count || 0,
        location_type: order.location_type || 'indoor',
        items: orderItemsData.map((item: any) => ({
          item_id: item.item_id,
          quantity: item.quantity,
          rate: item.unit_price || item.rate
        })),
        status: order.status,
        notes: orderData.notes || null
      };

      // Use the same retry logic as createOrder
      const currentOutletId = orderData.outlet_id;
      const currentCustomerId = orderData.customer_id;
      const currentUserId = user?.id;

      // Helper function to attempt invoice creation (same as in createOrder)
      const attemptCreateInvoice = async (_attemptNumber: number): Promise<any> => {
        // Fetch inventory item names
        const itemIds = orderFormData.items.map(item => item.item_id);
        const { data: inventoryItems } = await supabase
          .from('inventory_items')
          .select('id, name')
          .in('id', itemIds);

        const itemNameMap = new Map<string, string>();
        (inventoryItems || []).forEach((item: any) => {
          itemNameMap.set(item.id, item.name || 'Unknown Item');
        });

        // Fetch outlet and customer state
        let outletState: string | undefined;
        if (currentOutletId) {
          const { data: outletData } = await supabase
            .from('locations')
            .select('address')
            .eq('id', currentOutletId)
            .single();
          outletState = outletData?.address?.state;
        }

        let customerState: string | undefined;
        if (currentCustomerId) {
          const { data: customerData } = await supabase
            .from('customers')
            .select('address')
            .eq('id', currentCustomerId)
            .single();
          customerState = customerData?.address?.state;
        }

        // Build tax lines
        const taxLines: LineTaxInput[] = orderItemsData.map((it: any) => ({
          qty: Number(it.quantity) || 1,
          rate: Number(it.unit_price) || 0,
          gstRate: typeof it.gst_rate !== 'undefined' ? Number(it.gst_rate) : 18,
          outletState: outletState || '',
          customerState: customerState || ''
        }));

        const taxResult = calculateInvoiceFromLines(taxLines, 'DOMESTIC', outletState, customerState);

        // Calculate dates
        const invoiceDate = new Date().toISOString().split('T')[0];
        const eventDateObj = new Date(orderFormData.event_date);
        const dueDateObj = new Date(eventDateObj);
        dueDateObj.setDate(dueDateObj.getDate() + 7);
        const defaultDueDate = new Date();
        defaultDueDate.setDate(defaultDueDate.getDate() + 30);
        const dueDate = dueDateObj > defaultDueDate 
          ? dueDateObj.toISOString().split('T')[0]
          : defaultDueDate.toISOString().split('T')[0];

        // Create invoice
        const invoicePayload: any = {
          order_id: orderId,
          customer_id: currentCustomerId,
          invoice_date: invoiceDate,
          due_date: dueDate,
          invoice_type: 'rental',
          subtotal: roundToTwoDecimals(taxResult.taxable_value),
          taxable_value: roundToTwoDecimals(taxResult.taxable_value),
          cgst: roundToTwoDecimals(taxResult.cgst),
          sgst: roundToTwoDecimals(taxResult.sgst),
          igst: roundToTwoDecimals(taxResult.igst),
          total_gst: roundToTwoDecimals(taxResult.cgst + taxResult.sgst + taxResult.igst),
          total_amount: roundToTwoDecimals(taxResult.total_amount),
          payment_status: 'pending',
          notes: orderFormData.notes || `Invoice for order ${orderData.order_number}`,
          created_by: currentUserId || null
        };

        if (currentOutletId) {
          invoicePayload.outlet_id = currentOutletId;
        }

        const { data: invoiceData, error: invoiceErr } = await supabase
          .from('invoices')
          .insert(invoicePayload)
          .select()
          .single();

        if (invoiceErr || !invoiceData) {
          throw invoiceErr || new Error('Invoice creation returned no data');
        }

        // Create invoice items
        const invoiceItemsToInsert = taxResult.breakdown.map((line, index) => {
          const orderItem = orderItemsData[index];
          const itemName = orderItem ? itemNameMap.get(orderItem.item_id) || 'Rental Item' : 'Rental Item';
          const rentalDays = (orderItem as any)?.rental_days || 1;
          const quantity = orderItem ? orderItem.quantity * rentalDays : taxLines[index]?.qty || 1;
          
          return {
            invoice_id: invoiceData.id,
            description: itemName,
            quantity: roundToTwoDecimals(quantity),
            rate: roundToTwoDecimals(taxLines[index]?.rate || 0),
            gst_rate: taxLines[index]?.gstRate || 18,
            amount: roundToTwoDecimals(line.taxable),
            hsn_code: null
          };
        });

        if (invoiceItemsToInsert.length > 0) {
          const { error: invItemsErr } = await supabase
            .from('invoice_items')
            .insert(invoiceItemsToInsert);
          if (invItemsErr) {
            await supabase.from('invoices').delete().eq('id', invoiceData.id);
            throw invItemsErr;
          }
        }

        return { success: true, invoice: invoiceData };
      };

      // Retry logic with audit
      let lastErr: any = null;
      let createdInvoice: any = null;

      for (let attempt = 1; attempt <= MAX_INVOICE_CREATION_ATTEMPTS; attempt++) {
        try {
          const result = await attemptCreateInvoice(attempt);
          createdInvoice = result.invoice;

          // Write audit success
          await supabase.from('invoice_creation_audit').insert({
            order_id: orderId,
            invoice_id: createdInvoice.id,
            outlet_id: currentOutletId || null,
            requester_id: currentUserId || null,
            attempt_integer: attempt,
            success: true,
            error_message: null,
            metadata: { source: 'orderService.recreateInvoiceForOrder', order_number: orderData.order_number }
          });

          break;
        } catch (err: any) {
          lastErr = err;

          // Write audit failure
          await supabase.from('invoice_creation_audit').insert({
            order_id: orderId,
            invoice_id: null,
            outlet_id: currentOutletId || null,
            requester_id: currentUserId || null,
            attempt_integer: attempt,
            success: false,
            error_message: err?.message ? String(err.message) : String(err),
            metadata: { 
              attempt, 
              timestamp: new Date().toISOString(),
              source: 'orderService.recreateInvoiceForOrder',
              order_number: orderData.order_number
            }
          });

          if (attempt < MAX_INVOICE_CREATION_ATTEMPTS) {
            const backoffMs = Math.pow(2, attempt) * 200;
            await sleep(backoffMs);
          }
        }
      }

      if (!createdInvoice) {
        throw new Error(`Invoice recreation failed after ${MAX_INVOICE_CREATION_ATTEMPTS} attempts: ${lastErr?.message || lastErr}`);
      }

      // Fetch and return the full invoice
      const { InvoiceService } = await import('@/services/invoiceService');
      return await InvoiceService.getInvoice(createdInvoice.id);
    } catch (error: any) {
      console.error('Error in recreateInvoiceForOrder:', error);
      throw new Error(error.message || 'Failed to recreate invoice for order');
    }
  }

  /**
   * Delete an order (soft delete by setting status to cancelled)
   * Note: This will also handle related invoices if needed
   */
  static async deleteOrder(id: string): Promise<void> {
    try {
      // Update order status to cancelled (soft delete)
      const { error: updateError } = await supabase
        .from('rental_orders')
        .update({ 
          status: 'cancelled',
          updated_at: new Date().toISOString()
        })
        .eq('id', id);

      if (updateError) {
        console.error('Error deleting order:', updateError);
        throw new Error(updateError.message || 'Failed to delete order');
      }

      // Optionally, you can also delete related invoice if needed
      // For now, we'll just cancel the order
    } catch (error: any) {
      console.error('Error in deleteOrder:', error);
      throw new Error(error.message || 'Failed to delete order');
    }
  }
}
